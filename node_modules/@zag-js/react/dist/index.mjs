// src/index.ts
import { deepMerge, mergeProps } from "@zag-js/core";

// src/normalize-props.ts
import { createNormalizer } from "@zag-js/types";
var normalizeProps = createNormalizer((v) => v);

// src/portal.ts
import { createElement, useEffect, useLayoutEffect, useReducer, useRef } from "react";
import { createPortal } from "react-dom";
var useSafeLayoutEffect = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function Portal(props) {
  var _a;
  const { children, target } = props;
  const node = useRef(null);
  const portalNode = useRef(null);
  const [, forceUpdate] = useReducer((s) => s + 1, 0);
  useSafeLayoutEffect(() => {
    if (!node.current)
      return;
    const doc = node.current.ownerDocument;
    portalNode.current = doc.createElement("zag-portal");
    doc.body.appendChild(portalNode.current);
    forceUpdate();
    return () => {
      if (portalNode.current) {
        doc.body.removeChild(portalNode.current);
      }
    };
  }, []);
  const targetNode = (_a = target == null ? void 0 : target.current) != null ? _a : portalNode.current;
  if (targetNode) {
    return createPortal(children, targetNode);
  }
  return createElement("span", { ref: node });
}

// src/use-snapshot.ts
import { useCallback, useDebugValue, useEffect as useEffect2, useMemo, useRef as useRef2, useSyncExternalStore } from "react";
import { affectedToPathList, createProxy as createProxyToCompare, isChanged } from "proxy-compare";
import { snapshot, subscribe } from "@zag-js/store";
var __DEV__ = process.env.NODE_ENV !== "production";
var useAffectedDebugValue = (state, affected) => {
  const pathList = useRef2();
  useEffect2(() => {
    pathList.current = affectedToPathList(state, affected);
  });
  useDebugValue(pathList.current);
};
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = useRef2();
  const lastAffected = useRef2();
  let inRender = true;
  const currSnapshot = useSyncExternalStore(
    useCallback(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (!inRender && lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject)
  );
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  useEffect2(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if (__DEV__) {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxyToCompare(currSnapshot, currAffected, proxyCache);
}

// src/use-actor.ts
function useActor(service) {
  const current = useSnapshot(service.state);
  const typedState = current;
  return [typedState, service.send];
}

// src/use-machine.ts
import { useEffect as useEffect3, useLayoutEffect as useLayoutEffect2, useRef as useRef3 } from "react";
var useSafeLayoutEffect2 = typeof document !== "undefined" ? useLayoutEffect2 : useEffect3;
function useConstant(fn) {
  const ref = useRef3();
  if (!ref.current)
    ref.current = { v: fn() };
  return ref.current.v;
}
function useService(machine, options) {
  const { actions, state: hydratedState, context } = options != null ? options : {};
  const service = useConstant(() => {
    const _machine = typeof machine === "function" ? machine() : machine;
    return context ? _machine.withContext(context) : _machine;
  });
  useSafeLayoutEffect2(() => {
    service.start(hydratedState);
    if (service.state.can("SETUP")) {
      service.send("SETUP");
    }
    return () => {
      service.stop();
    };
  }, []);
  service.setOptions({ actions });
  service.setContext(context);
  return service;
}
function useMachine(machine, options) {
  const service = useService(machine, options);
  const state = useSnapshot(service.state);
  const typedState = state;
  return [typedState, service.send, service];
}
export {
  Portal,
  deepMerge,
  mergeProps,
  normalizeProps,
  useActor,
  useMachine,
  useService
};
